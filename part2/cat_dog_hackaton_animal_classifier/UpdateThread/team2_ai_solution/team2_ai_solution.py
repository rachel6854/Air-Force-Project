# -*- coding: utf-8 -*-
"""team2_ai_notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GbsYCSNSXzweZQIa3M-ILwI52LJ0nDVj

# אתגר 2

## ידע נדרש לפתירת האתגר:

1. יכולת לכתוב ולהבין קוד בסיסי בפייתון
2. הכרות עם ספריית pandas - בעיקר שימוש בסיסי ב-data frames
3. הבנת המשמעות של feature engineering וחשיבותם בתהליך למידת המכונה. הבנה בסיסית על הקשר שבין ידע עסקי ו- features של מודל סטטיסטי.

## מבוא - הצגת הבעיה

אתגר זה עוסק בסיווג של חיות על סמך גרפים שמייצגים את התנועה שלהם. <br>
הרחפן במערכת מגיע למשבצת ואוסף מידע סנסורי המרוכז לגרף תנועה. גרף תנועה הינו רשימה של רביעיות מהצורה:
 [(ts_1,x_1,y_1,z_1),....,(ts_n,x_n,y_n,z_n)] <br>
הגרף למעשה מייצג מיקומי גוף (יכול להיות חיה, יכול להיות רעש) במשבצת לאורך דקה שלמה של איסוף. <br>כל המיקומים מחושבים יחסית לראשית מסויימת בתוך המשבצת (ולכן כל הקורדינטות הם  בטווח
[0,1000] שכן משבצת היא בגודל 1000 מטר על 1000 מטר). <br>
חותמות הזמן מייצגות באיזה זמן בתוך דקת האיסוף נקלט המיקום. כך למשל הרביעייה: (12, 50, 100, 4)
מייצגת שהרחפן קלט מידע בשנייה הרביעית בתוך הדקה המצביע על מיקום גוף ב- X=100 מטר, Y=50 מטר ו- Z=12 מטר בתוך המשבצת. <br>

<br>
באתגר זה, תקבלו מדגם אימון של חיות (או רעש) והגרפים שהרחפנים אספו עבור אותם החיות (או רעש).
המשימה שלכם היא ללמוד מודל סטטיסטי אשר יסווג גוף על סמך גרף התנועה שהרחפן אסף עבורו (כלומר, יסווג על סמך גרף התנועה, האם הגוף שנקלט הינו חתול, כלב, תוכי, 
ארנב או למעשה גרף שמייצג רעש - כלומר שאין חיה במשבצת). 
<br><br>
אתם תישלחו את המודל שלמדתם לשרת שלנו, ואנו נעשה בו שימוש כדי לזהות חיות במשבצות על סמך הגרפים שהרחפנים שלנו יאספו.
<br>
בעזרת יכולת זו נוכל לשלוח מאמצים למשבצות בצורה אוטומטית, שכן בעזרת המודל יהיה לנו יכולת טובה להבין מה יש באותה המשבצת, ובכך לבסס את החלטנו.

## ונעבור לאתגר עצמו...

ישנם שתי פונקציות שעליכם לממש:
1. compute_features_df(plots) -  על פונקציה זו לחשב פיצ'רים לכל גרף תנועה, אשר בהם יעשה מודל למידת המכונה שימוש לצורך תהליך הלמידה והחיזוי
2. learn_model(labeled_plots) - פונקציה זו תקבל את מדגם האימון ותלמד מודל סטטיסטי מתוכו. הפונקציה עושה שימוש בפונקציה compute_features_df(plots)

המערכת תעשה שימוש ב-2 פונקציות אלו, אשר תממשו, על מנת ללמוד מודל סטטיסטי שיסווג חיות על סמך גרף התנועה שלהם, וכמובן כדי להשתמש באותו
המודל לצורך סיווג חיה מתוך גרף תנועה חדש שנאסף על ידי רחפן.

סיפקנו לכם במחברת זו פתרון בסיסי עבור פונקציות אלו. עליכם לנסות לשפר פתרון זה על מנת שתוכלו ללמוד מודל טוב יותר אשר מסווג בצורה מדוייקת יותר חיות על
סמך גרף התנועה שלהם.

בסוף המחברת, ישנו חלק "הערך את עצמך" באמצעותו תוכל לבחון עד כמה המודל שלמדתם מדוייק וטוב. 
אנו ממליצים לכם בחום רב לא לנסות ולהפוך את המודל למושלם בבת אחת - נסו לשפר אותו בשלבים (בעיקר על ידי מימוש פיצ'ר נוסף בכל פעם). לאחר כל שלב, בידקו
את המודל על ידי החלק "הערך את עצמך" וכך תוכלו לראות עד כמה המודל טוב ואיפה הוא טועה ולהמשיך לשפרו במקומות הנכונים. באופן זה גם יהיה לכם פתרון עובד
להגיש בכל רגע נתון, ותימנעו ממצב בו לא יהיה לכם זמן לממש את הרעיונות שלכם ולא תוכלו להגיש שום פתרון.

כאשר מממשים מודל, מרבית המאמצים צריכים להיות ממוקדים בחישוב פיצ'רים שיכולים לסייע בסיווג. לכן גם כאן, הפונקציה המרכזית שאנו ממליצים לכם להתמקד בשיפורה
במחברת זו היא הפונקציה compute_features_df(plots).

כמו בכל בעיה אמיתית, כדי לחשב פיצ'רים טובים, עליכם להיות בעלי הבנה עסקית טובה - בהקשר זה: להבין אילו פיצ'רים של גרף תנועה יכולים
לסייע לכם להבחין בין חיות (ובין הימצאותה של חיה במשבצת לאי הימצאותה).
לצורך כך סיפקנו לכם את כל הידע העסקי הרלוונטי לפתרון הבעיה, בחלק הבא של המחברת:

## ידע עסקי על התנהגותם של חיות

1. כל משבצת בלוח יכולה להכיל את אחת מהחיות הבאות: 'rabbit', 'parrot', 'cat', 'dog', 'None'
    ('None' מייצג שאין חיה במשבצת)

2. קשה לסנסורים של רחפן לזהות חיות קטנות ומהירות, לכן במקרים שכאלו ככל הנראה יהיה מידע חסר בגרף התנועה שהרחפן אסף (כלומר, נקודות זמן בהם אין דגימות). 
    ככל שהחיה זזה באופן מוזר ומהיר יותר - כך יש יותר "חורים" בגרף התנועה של החיה (כלומר, נקודות זמן בהם אין מידע על מיקום החיה, בגרף התנועה של החיה)

3. ישנם חיות שיש להם יכולת תנועה מהירה יותר מחיות אחרות

4. ישנם חיות אשר נוטות לנוע במקומות קטנים וסגורים, בעוד שחיות אחרות נעות באזורים פתוחים ונרחבים יותר. כלומר: נוודים מול יושבי קבע

5. תוכים עפים בעוד שחיות אחרות נעות על פני הקרקע

6. חיות בקרקע נוטות לקפוץ מעת לעת - הנטייה של חיה לקפוץ משתנה מחיה לחיה, וגם גודל הקפיצה של חיה שונה בין סוגי חיות שונים

## הפונקציות שעליכם לממש

הפונקציה המרכזית שאנו ממליצים לכם להתמקד בה היא הפונקציה: compute_features_df(plots).<br>
פונקציה זו מחשבת פיצ'רים לכל גרף תנועה של חיה.
על הפיצ'רים לייצג את התנהגותה של החיה, באמצעות מספר בודד. <br> 
בסופו של דבר, פונקציית למידת המכונה תעשה שימוש בפיצ'רים שחישבתם בפונקציה זו על מנת
ללמוד מודל שבהינתן גרף תנועה של חיה יחזה את סוג החיה המתאימה לגרף זה.<br>
כדי לקרוא מעט יותר על פיצ'רים ואיך לחשבם, ניתן להיעזר בקישורים הבאים (לפי הסדר): <br>
<br>
https://en.wikipedia.org/wiki/Feature_(machine_learning) <br>
https://www.quora.com/What-is-feature-engineering   <br>
https://machinelearningmastery.com/discover-feature-engineering-how-to-engineer-features-and-how-to-get-good-at-it/  <br>

<br>
כדי לממש את הפיצ'רים הרלוונטיים עליכם להתמקד במידע העסקי שהובא בחלק הקודם, ולנסות לכמת את התנהגויות החיות המתוארות בו באמצעות הפיצ'רים הרלוונטיים.
למשל: בפתרון הבסיסי שסיפקנו לכם, מידלנו את התנהגות מס' 6 אשר מופיע במידע העסקי באמצעות פיצ'ר. נסו לחשוב כיצד אתם יכולים למדל את שאר ההתנהגויוץת.
"""

import pandas as pd
def compute_features_df(plots):
    """
    קלט:
        plots - רשימה של גרפי תנועה של חיות, כלומר רשימה מהצורה:
                [plot_1, plot_2,..., plot_n]
                כל גרף ברשימה זו מיוצג באמצעות רשומה של רביעיות. כלומר כל גרף ברשימה זו יהיה מהצורה הבאה:
                [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
                הערה: ניתן להניח שגובה פני הקרקע הוא 0 בכל רגע נתון, כלומר אין טופוגרפיה.
    פלט: 
        דאטה-פריים של פנדה המכיל את הפיצ'רים שחושבו
    """
    total_jumps = [computeTotalJumps(plot) for plot in plots]
    avg_jump = [computeAvgJumps(plot) for plot in plots]
    total_distance=[computeDistance(plot) for plot in plots]
    max_dis=[computeMaxDist(plot) for plot in plots]
    min_dis=[computeMinDist(plot) for plot in plots]
    dif_dis=[computeDifDist(plot) for plot in plots]
    max_jump=[computeMaxJump(plot) for plot in plots]
    change_direct=[computeChabgeDirection(plot) for plot in plots]
    period_lost=[periodOfPlot(plot) for plot in plots]
    # נסו לחשב עוד פיצ'רים בהתאם למידע העסקי שהובא ולהוסיף אותם לדטה-פריים:
    df = pd.DataFrame({"total_jumps": total_jumps,
                       "jumpOverTwoMeters":avg_jump,
                       "distance":total_distance,
                       "maxDist":max_dis,
                       "minDist":min_dis,
                       "difDis":dif_dis,
                       "maxJump":max_jump,
                       "changeDirection":change_direct,
                       "period":period_lost})
    return df

def computeTotalJumps(plot):
    """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            מספר הנקודות בגרף שהינן קפיצה - קורלטיבי להסתברות של חיה לקפוץ.
    """
    # שימו לב: פיצ'ר זה רחוק מלהיות מדוייק (למשל, חישבו מה קורה כאשר חיה מבצעת קפיצה ארוכה שאורכת יותר ממספר שניות) , אולם חשוב להבין שכאשר
    # ממדלים התנהגויות באמצעות פיצ'רים, אין תמיד צורך לחשב את הפיצ'ר בצורה הכי מדוייקת, אלא לתפוס מספר מספיק משמעותי שיבטא התנהגויות שונות בין חיות
    # לכן, במחברת זו (ובחיים) - הימנעו מלהשקיע יותר מידי זמן במימוש פיצ'רים בצורה הכי מושלמת ונסו להסתפק במידול סביר תוך כיסוי כל ההתנהגויות.
    return sum([point[-1]>0 for point in plot])


def computeAvgJumps(plot):
    """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            ממוצע גובה הקפיצה עבור כל דקה - קורלטיבי להסתברות של חיה לקפוץ.

  """

    # שימו לב: פיצ'ר זה רחוק מלהיות מדוייק (למשל, חישבו מה קורה כאשר חיה מבצעת קפיצה ארוכה שאורכת יותר ממספר שניות) , אולם חשוב להבין שכאשר
    # ממדלים התנהגויות באמצעות פיצ'רים, אין תמיד צורך לחשב את הפיצ'ר בצורה הכי מדוייקת, אלא לתפוס מספר מספיק משמעותי שיבטא התנהגויות שונות בין חיות
    # לכן, במחברת זו (ובחיים) - הימנעו מלהשקיע יותר מידי זמן במימוש פיצ'רים בצורה הכי מושלמת ונסו להסתפק במידול סביר תוך כיסוי כל ההתנהגויות.
    jumps=[point[-1] for point in plot if [point[-1]>0]]
    return sum(jumps)/len(jumps)
  

def computeDistance(plot):
  """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            סכום המרחק עבור כל דקה - המרחק שעברה כל חיה בדקה אחת.

  """
  dis=0
  for i in range(len(plot)-1):
    a=plot[i+1][1]-plot[i][1]
    b=plot[i+1][2]-plot[i][2]
    dis+=(a**2+b**2)**0.5
  return dis


def computeMaxDist(plot):
  """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            מקסימום מרחק שעברה החיה בדקה אחת- קורלטיבי מהירות החיה.

  """
  dis=[]
  for i in range(len(plot)-1):
    a=plot[i+1][1]-plot[i][1]
    b=plot[i+1][2]-plot[i][2]
    dis.append((a**2+b**2)**0.5)

  return max(dis)


def computeMinDist(plot):
  """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            מינימום מרחק שעברה החיה בדקה אחת- קורלטיבי האם החיה נחה

  """
  dis=[]
  for i in range(len(plot)-1):
    a=plot[i+1][1]-plot[i][1]
    b=plot[i+1][2]-plot[i][2]
    dis.append((a**2+b**2)**0.5)
  return min(dis)


def computeDifDist(plot):
  """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            הפרש בין מינימום מרחק למקסימום מרחק- קורלטיבי התקדמות החיה.

  """
  dis=[]
  for i in range(len(plot)-1):
    a=plot[i+1][1]-plot[i][1]
    b=plot[i+1][2]-plot[i][2]
    dis.append((a**2+b**2)**0.5)
  return max(dis)-min(dis)



def computeMaxJump(plot):
  """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            .מקסימום קפיצה בדקה

  """
  return max([point[-1] for point in plot])


def computeChabgeDirection(plot):
  """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            .מספר שינויי כיוון- נגזרת ראשונה

  """
  count=0
  for i in range(1,len(plot)-1):
    x_prev=plot[i+1][1]-plot[i][1]
    x_next=plot[i][1]-plot[i-1][1]
    y_prev=plot[i+1][2]-plot[i][2]
    y_next=plot[i][2]-plot[i-1][2]
    if (x_next>0 and x_prev<0) or (x_next<0 and x_prev>0):
      count+=1
    if (y_next>0 and y_prev<0) or (y_next<0 and y_prev>0):
      count+=1
  return count


def periodOfPlot(plot):
  """
    קלט:
        plot:
            רשימה מהצורה:
            [(ts_1, x_1, y_1, z_1),...., (ts_n, x_n, y_n, z_n)]
            רשימה זו מייצגת תנועה של חיה בתוך משבצת במשך דקה של איסוף מידע. 
    פלט:
            .מספר איבודי מידע עקב התקדמות מהירה או מוזרה

  """
  return len(plot)

import numpy as np
from sklearn.ensemble import RandomForestClassifier

def train_model(features_vectors, labels):
    """
    קלט:
        features_vectors - pandas dataFrame that contain features_vectors computed from the train data using
            the compute_features_df(plot) function you implemented above.
    
        labels - the labels of the features vectors. i.e. labels[i] is the animals that corresponds to the feature_vector
                in features_vectors[i]. 
        
    output:
        מודל שאומן על מדגם האימון (Scikit-learn model)
    """
    # זהו שלב האימון עצמו. כאן נבצע את הלמידה באמצעות אלגוריתם רנדום-פורסט. מדובר במודל מצויין ואנו לו ממליצים להשקיע יותר מידי
    # זמן בלנסות למצוא מודל טוב יותר - השיפור המרבי טמון בשיפור הפיצ'רים מהפונקציה הקודמת (כמו בעולם האמיתי):
    model = RandomForestClassifier(n_estimators=1000).fit(features_vectors, labels)
    return model

"""## העריכו את עצמכם:

בחלק זה נסייע לכם להעריך עד כמה המודל שלמדתם מוצלח.
כדי להריץ חלק זה, היעזרו בקובץ ה-pickle שסיפקנו לכם (תוכלו להוריד אותו מספריית הגיט)
<br>
שימו את קובץ ה-pickle במקום נוח במחשב שלכם, ועדכנו את הכתובת שלו במחשב המקומי בשורת הקוד הבאה:
"""

# עליכם לשנות קבוע זה לכתובת בו שמרת את פיקל האימון במחשב המקומי שלכם
TRAIN_DATA_PATH = "train_data.pickle"

"""מצויין!
כעת הריצו את הקוד בחלק הבא.
קוד זה מבצע את הדברים הבאים:
1. מטעין את מדגם האימון מתוך קובץ ה-pickle
2. מחשב פיצ'רים על מדגם האימון על ידי הפונקציה שמימשתם (compute_features_df)
3. מחלק את וקטורי הפיצ'רים לקבוצת אימון וקבוצת ולידציה
4. לומד מודל סטטיסטי על קבוצת האימון על ידי שימוש בפונקציה train_model שמימשתך
5. מעריך את איכות המודל שנלמד על קבוצת הולידציה, ומערך את הדיוק של המודל ואת ה-confusion_matrix שלו למסך
"""

import pickle
import numpy as np
from sklearn.metrics import confusion_matrix

def load_train_data(path):
    """
    פונקציה זו טוענת את מדגם האימון מתוך קובץ הפיקל
    """
    with open(path, 'rb') as f:
        labeled_plots = pickle.load(f)
    return labeled_plots

def split_train_test(df):
    """
    df:
        דאטה-פריים של פנדה שמכיל וקטורי פיצ'רים ועמודה של תגיות עבורם
    return:
        הפונקציה תחלק את הדאטה-פריים ל-4 קבוצות:
        train_x - וקטורי פיצרים של מדגם אימון
        train_y - תגיות של מדגם האימון
        test_x - וקטורי פיצ'רים של קבוצת המבחן
        test_y - תגיות של קבוצת המבחן
        החלוקה מתבצעת באופן אקראי כך ש-80 אחוזים מהמידע נמצאים מדגם האימון ו-20 אחוז האחרים נמצאים בקבוצת המבחן.
    """
    split_mask = np.random.rand(len(df)) < 0.8
    x_train = df[split_mask]
    y_train = x_train["label"]
    x_train.drop(["label"], axis=1, inplace=True)
    x_test = df[~split_mask]
    y_test = x_test["label"]
    x_test.drop(["label"], axis=1, inplace=True)
    return x_train, y_train, x_test, y_test

from matplotlib.colors import LogNorm

import seaborn as sns
def evaluate_predictions(predictions, labels):
    """
    predictions:
        החיזויים שהמודל הסטטיסטי נתן על קבוצת הולידציה
    labels:
       התיוגים האמיתיים של הוקטורים בקבוצת הולידציה
    
    הפונקציה תדפיס את הדיוק של המודל ואת מטריצת הבלבול שלו. אלו יכולים לסייע לכם להעריך את המודל ולהבין באילו מקרים הוא טועה
    """
    total_accuracy = np.mean(predictions==labels)
    #  כלל שהדיוק גבוה יותר, כך המודל טוב יותר. מודל עם 100 אחוז דיוק הוא מודל מושלם
    # עבור אתגר זה, מודל עם דיוק של מעל 95 אחוזים הוא מודל טוב, ועם דיוק של מעל 98 אחוזים הוא מודל מצויין

    print("total accuracy: {0}".format(total_accuracy))
    # מטריצת בלבול היא דרך מצויינת לבדוק באילו מקרים המודל שלכם טועה. אנו ממליצים לכם לעיין בקישורים הבאים כדי להבין כיצד לנתח מטריצה זו:
    # https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html
    # https://stats.stackexchange.com/questions/95209/how-can-i-interpret-sklearn-confusion-matrix
    print("confusion matrix:")
    matrix = confusion_matrix(labels, predictions, labels=["None", "dog", "cat", "rabbit", "parrot"])
    print(matrix)
    sns.heatmap(matrix,  norm=LogNorm())

labeled_plots = load_train_data(TRAIN_DATA_PATH)
df = compute_features_df([plot for plot, label in labeled_plots]) 
df["label"] = [label for plot, label in labeled_plots]
x_train, y_train, x_test, y_test = split_train_test(df)

model = train_model(x_train, y_train) #  כאן אנו לומדים מודל באמצעות הפונקציה שמימשתך
predictions = model.predict(x_test) # ביצוע חיזויים על קבוצת המבחן, באמצעות המודל שנלמד
# חלק זה ידפיס הערכות על המודל שלכם, אנא קראו את מימוש הפונקציה כדי להבין כיצד לנתח את הפלטים המודפסים
evaluate_predictions(predictions, y_test)

"""# Explore plots
##### to show the difference between the items you can use this part.
"""

with open('train_data.pickle', 'rb') as f:
  data = pickle.load(f)
id = 300
pd.DataFrame(data[id][0])[1].plot()
data[id][1]

"""## שליחת הפתרון שלכם

סיימתם? הידד! כעת הגיעה הזמן לשלוח את הפתרון שלכם לשרת שלנו.
לצורך כך, אנא עקבו אחרי הצעדים הבאים:

1. העתיקו את הקוד שלכם לקובץ פייתון. ניתן לעשות את זה בנקל בדרך הבאה: <br>
    a. הקליקו על "File" בתפריט העליון (פינה ימנית או שמאלית) <br>
    b. בתפריט שנפתח, הקליקו על "Download as" <br>
    c. כעת, בתת התפריט שנפתח הקליקו על "python" <br>
    d. שנו את שם הקובץ שלכם ל- "team2_ai_solution.py" ושימרו אותו במקום נוח במחשב שלכם <br><br>
2. פיתחו את הקובץ ששמרתם בסביבת הפיתוח המועדפת עליכם (notepad++ יהיה לגמרי בסדר עבור צורך זה)
<br><br>
3. מחקו מקובץ הפייתון שלכם את כל הקוד שנמצא אחרי החלק: "העריכו את עצמכם", כך שבסופו של יום אתם צריכים להשאיר בקובץ רק את הפונקציות compute_features_df ו- train_model 
    וכמובן כל פונקציות העזר האחרות הדרושות עבורן. <br>
    תוכלו להסתכל על קובץ הפייתון הבסיסי שנמצא בספריית הגיט של האתגר, כדי להבין כיצד על קובץ זה להיראות
<br> <br>
4. דיחפו את הקוד שלכם לספריית ה-git

### בהצלחה!
"""